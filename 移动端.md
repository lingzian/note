1、适配
屏幕分辨率：指一个屏幕集体有多少个像素点组成
物理像素： 设备上真实的物理单元（设备像素）
设备独立像素（逻辑像素）： css像素
设备像素比： DPR = 物理像素 / 设备独立像素


一倍屏 二倍屏 三倍屏（dpr为1、2、3）：指的是设备以多少物理像素来显示一个css像素，（二倍屏幕在横竖方向上就需要四个物理像素渲染一个css像素） 
视口缩放（viewport ）最初手淘libflex rem方案是把屏幕宽度切割成10份 1个rem = 1/10屏幕宽度（当时是因为担心vw有些浏览器不兼容）,同时在viewport
上设置initial-scale = 1/dpr，以二倍屏为例 dpr为2 缩放就为0.5, 在普通宽为320的设备上 视口就被缩放成640， 然后设置的font-size * 2,总体来说视口放大，rem的值也变大同等
倍数。这里解决的问题是当我们设置1px的border的时候，在二倍屏幕上会模糊，总体看起来会变大。但是设置了视口缩放，再写1px 就能解决此问题。（因为本来是横竖方向上一个屋里像素渲染了四个css像素，现在视口放大，物理像素就能一对一渲染，就不会取临近色，导致模糊，看起来大了。）

后来 手淘放弃了viewport的缩放，因为这会导致很多问题发生，获取的设备宽度会被放大，还有其他导致表情符号被缩小的问题

后来，在多倍屏幕下 图片模糊（看起来被放大）建议使用多倍图， 1px的问题可以自己使用css缩放，或者使用border-img


目前方案：
针对移动端，结合JS依据屏幕宽度与设计图宽度的比例动态声明<html>的font-size，以rem为长度单位声明所有节点的几何属性，这样就能做到大部分移动设备的页面兼容，
兼容出入较大的地方再通过媒体查询做特别处理。
笔者通常将rem布局比例设置成1rem=100px，即在设计图上100px长度在CSS代码上使用1rem表示。
function AutoResponse(width = 750) {
    const target = document.documentElement;
    if (target.clientWidth >= 600) {
        target.style.fontSize = "80px";
    } else {
        target.style.fontSize = target.clientWidth / width * 100 + "px";
    }
}
AutoResponse();
window.addEventListener("resize", () => AutoResponse());
