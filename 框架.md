`写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？`
就我的使用来说(Vue)key的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。另外，某些情况下不带key可能性能更好
如果用index作为key，和不带key的效果是一样的。index作为key时，每个列表项的index在变更前后也是一样的，都是直接判断为sameVnode然后复用。











`聊聊 Redux 和 Vuex 的设计思想`
共同点
首先两者都是处理全局状态的工具库，大致实现思想都是：全局state保存状态---->dispatch(action) ------>reducer(vuex里的mutation)----> 生成newState; 整个状态为同步操作；

区别
最大的区别在于处理异步的不同，vuex里面多了一步commit操作，在action之后commit(mutation)之前处理异步，而redux里面则是通过中间件处理


`纯函数的概念:`
相同的输入永远得到相同的输出.且没有任何可观察的副作用.比如一个加法函数.输入参数1,1 输出结果永远是2，这个加法函数就属于纯函数 (不依赖外部状态，例如 异步请求会报错，会返回不一样的东西)


`Vue 的双向数据绑定`
是单向绑定，只是 m -> v，在 vue 2.x 中 通过 defineProperty 实现的数据劫持，getter 收集依赖，setter 调用更新回调，这个过程是 vue 黑盒提供的，也就是说数据驱动视图，开发人员只需关注数据的变更即可；再说 v -> m，通过 v-model 的方式，指令添加是开发人员加的吧，如果一个组件有多个 v-model ，你要自己写 v-on 和 data 的修改


`为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？`
因为更改state的函数必须是纯函数，纯函数既是统一输入就会统一输出，没有任何副作用；如果是异步则会引入额外的副作用，导致更改后的state不可预测；


`双向绑定和 vuex 是否冲突`
在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。当需要在组件中使用vuex中的state时，有2种解决方案： 1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值 2、使用带有setter的双向绑定计算属性




`Vue 的响应式原理中 Object.defineProperty 有什么缺陷？`
Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组 push() pop()...  属性也为object的时候 向Object添加属性/ 删除Object的属性也是检查不到（ 无法深度监听）

而要取代它的Proxy有以下两个优点;
可以劫持整个对象，并返回一个新对象 有13种劫持操作
·



`Vue 的父组件和子组件生命周期钩子执行顺序是什么`
加载渲染过程 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
子组件更新过程 父beforeUpdate->子beforeUpdate->子updated->父updated
父组件更新过程 父beforeUpdate->父updated
销毁过程 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed



`react-router 里的 <Link> 标签和 <a> 标签有什么区别`
从最终渲染的 DOM 来看，这两者都是链接，都是 <a> 标签，区别是： <Link> 禁用了 a 标签的默认事件 并且是 react-router 里实现路由跳转的链接，




`vue和 react 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？`
vue只有在非常非常多的节点中，使用事件代理会提高一点性能，否则绑定在每个节点中几乎没有差别(节点多的时候尽量绑定的都是同一函数)

react 是委托到 document 上, 然后自己生成了合成事件, 冒泡到 document 的时候进入合成事件, 然后他通过 getParent() 获取该事件源的所有合成事件, 触发完毕之后继续冒泡



`vue 渲染大量数据时应该怎么优化？`
服务器渲染组件总比浏览器强，毕竟那么多核的CPU也不是花瓶
增加加载动画提升用户体验
尽量不要再用vue的双向数据绑定了 或者只用部分页面中处理的数据


`vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？`
白屏是，其原因是因为它是一个单页应用，需要将所有需要的资源都下载到浏览器端并解析。
优化 webpack 减少模块打包体积，code-split 按需加载
服务端渲染，在服务端事先拼装好首页所需的 html
首页加 loading 或 骨架屏 （仅仅是优化体验）



`vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法`
变异的本质就在这些方法内部加上自定义的逻辑，其实就是想监听这些方法的调用。



`谈一谈 nextTick 的原理`
<!-- data: {
  number:1
}
methods: {
    handleClick () {
        for(let i = 0; i < 1000; i++) {
            this.number++;
        }
    }
}
当我们按下 click 按钮的时候，number 会被循环增加1000次。 -->
1 每次 number 被 +1 的时候，都会触发 number 的 setter 方法, 对应的 Watcher 对象其实会被 push 进一个队列 queue 中,在下一次时间循环中调用watcher的update方法，（在更新前 会过滤一样的watcher，使得最终只更新一次dom结果为1000）
Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。
然后 nextTick 方法回调是在试图更新后调用，这里分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件放到队列里面（一般是微任务，版本不同用的也不一样），目的是在当前调用栈执行完毕以后才会去执行这个事件。
总结（
nexttick是会在dom更新之后直行回调函数，这里就要涉及到veu的异步更新，当改变data的时候会触发object.defineProperty的setter，然后他就会去dep里面去找相应的watcher，然后把watcherWatcher加入到Queue队列里并且去重，等到当前时间循环结束，然后把watcher的更新操作都放到nexttick函数里面，nexttick里面其实主要是包裹了一层promise 或者setTimeout（具体是哪一个就要看版本或者环境）,这样的话他就会在当前事件循环之后或者是在微任务中执行更新。然后本身用户写的nextTick会在data修改之后执行，所以用户写的nexttick会在dom更新之后执行。


在 nextTick 函数接受到一个 callback 函数的时候，先不去调用它，而是把它 push 到一个全局的 queue 队列中，等待下一个任务队列的时候再一次性的把这个 queue 里的函数依次执行。
这个队列可能是 microTask 队列，也可能是 macroTask 队列，前两个 api 属于微任务队列，后两个 api 属于宏任务队列。）


`Vue 中的 computed 是如何实现的`
在computed初始化中遍历每一个computed属性，创建对应的Watcher。在Watcher实例化过程中，计算computed属性结果，会对依赖的data进行取值，从而触发data的getter进行依赖收集，将当前Watcher加入到订阅者数组中。当computed属性依赖的data改变时，会触发data的setter通知订阅者更新，这个computed会重新计算。



`Vue 中的 computed 和 watch 的区别在哪里`
共同点：都是监听数据变化的方法，用来观察和响应Vue实例上的数据变动。可以将复杂的逻辑放入到计算属性和watch 中，从而使得代码更加整齐，分工明确

watch: 
支持异步， 
就是单纯的是监听某个数据的变化，支持深度监听

computed： 
是计算属性，是依赖于某个或者某些属性值，只有当依赖的数据发生变化时，才会发生变化；
不支持异步



`v-if、v-show、v-html 的原理是什么，它是如何封装的？`
v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染； v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值


`vue有了数据响应式，为何还要diff？`
React通过setState知道有变化了，但不知道哪里变化了，所以需要通过diff找出变化的地方并更新dom。
Vue已经可以通过响应式系统知道哪里发生了变化，但是所有变化都通过响应式会创建大量Watcher，极其消耗性能，因此vue采用的方式是通过响应式系统知道哪个组件发生了变化，然后在组件内部使用diff。这样的中粒度策略，即不会产生大量的Watcher，也使diff的节点减少了，一举两得。
