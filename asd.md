pixi.js 
他是一个2D渲染引擎，它能自动侦测使用WebGL还是Canvas来创建图形
它的持续渲染还是通过requestAnimationFrame实现的. 
requestAnimationFrame 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画
一般每秒60次，具体要看屏幕的刷新率
为什么不用定时器：大部分浏览器的显示频率是16.7ms，由于浏览器的特性，setInterval会有一个丢帧的问题
即使向其传递毫秒为单位的参数，它们也不能达到ms的准确性。这是因为javascript是单线程的，可能会发生阻塞
开发着并不知道下一刻绘制动画的最佳时机是什么时候



cocos creator
是一个完整的游戏开发解决方案
有自己的编辑器东西比较全 可以开发 预览 调试 发布（各种平台），对于大型游戏开发速度比较快。
很多效果页面直接从编辑器上面完成，代码上只需关注业务逻辑


超多个场景切换卡这个性能怎么处理？
把暂时不需要的节点隐藏，通过脚本来控制节点的active，这样也可以节省渲染的时间

编辑器界面超多个节点，导致开发太卡怎么处理？
减少绘制调用，不用的节点可以清除，或者一个图上面的的节点可以做成一张图（多个精灵绘制成一个）



业务上面

面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；
（初始化地图，开始游戏，炮塔建造，子弹生成，海盗生成，子弹击中目标爆炸，海盗血量减少，海盗死亡，一路上都是用函数，然后各种生成的单位（例如炮台）都存到最外面的函数上面，然后各种东西一多就会非常混乱，扣血的话又要从扣血函数里面再外面找谁扣血，然后扣血逻辑，逻辑非常耦合）

面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
所有精灵都是一个类，比如炮台类，里面有生成方法，扣血方法，销毁方法，外面还可以直接更改一些静态属性，或者方法。逻辑上面就很清晰，每个类负责自己的工作







`pingou-web : `

framework7: webpack自己配置，没有优化，启动速度慢。 可配置异步路由

typescript:

apicloud:

umi-request：是基于 fetch 封装的开源 http 请求库 
URL 参数自动序列化
POST 数据提交方式简化
Response 返回处理简化
请求超时处理
请求缓存支持


hox： 单例模式的一个自定义hook（各个页面引用统一model，并且能同步数据）
dva:

pixi:

fundebug：异常监控

