react 
`Context`: Context 设计用来解决祖先组件向后代组件传递数据的问题（prop drilling）。为跨层级的组件搭建一座桥梁。
举个例子：用户登录之后，很多组件需要拿到用户相关信息，如果按照prop传递的方式获取，会变得异常繁琐，而且很难判断数据的真正来源
有同学可能要问，使用redux不也可以解决这个问题吗？答案是：你说的对。不过redux本身就是通过context实现的。

步骤 1. 通过createContext创建Context 2. 使用Context.Provider组件发布数据（通过给Context.Provider传递value属性）。 3. Context.Providr的所有后代组件，都可以通过Context.Consumer消费数据(或者使用 useContext)


umi 中的const { initialState, setInitialState } = useModel('@@initialState') 
外部包裹了一个Context然后把值用hook管起来



`Reconciler（协调器）`
我们知道，在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等API触发更新。

每当有更新发生时，Reconciler会做如下工作：

调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM
将虚拟DOM和上次更新时的虚拟DOM对比
通过对比找出本次更新中变化的虚拟DOM
通知Renderer将变化的虚拟DOM渲染到页面上

`React15架构`
React15架构可以分为两层：
Reconciler（协调器）—— 负责找出变化的组件
Renderer（渲染器）—— 负责将变化的组件渲染到页面上
`React15架构的缺点`
在Reconciler中，mount的组件会调用mountComponent (opens new window)，update的组件会调用updateComponent (opens new window)。这两个方法都会递归更新子组件。

#递归更新的缺点
由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。



`React16架构`
React16架构可以分为三层：
🔴Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler
可以看到，相较于React15，React16中新增了Scheduler（调度器），
既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。
其实部分浏览器已经实现了这个API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用：
浏览器兼容性
触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低
基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。
🔴Reconciler（协调器）—— 负责找出变化的组件
我们知道，在React15中Reconciler是递归处理虚拟DOM的。
更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。有的话就继续处理 （一般只给出30ms执行，时间不够就不会继续执行，等待下一次）

🔴Renderer（渲染器）—— 负责将变化的组件渲染到页面上
根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。

`Fiber 是 React 16 中新的协调引擎或重新实现核心算法。`
🔴Fiber Reconciler 在阶段一进行 Diff 计算的时候，会生成一棵 Fiber 树。这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表(上一个节点指向下一个个节点和父节点还有兄弟节点，通过这些信息来遍历)。
🔴主流浏览器刷新频率为60Hz，即每（1000ms / 60Hz）16.6ms浏览器刷新一次。在每16.6ms时间内需要完成如下工作： JS脚本执行 -----  样式布局 ----- 样式绘制
由于 GUI 渲染线程和 JS 线程是互斥的，所以 JS 脚本执行和浏览器布局、绘制不能同时执行。在这 16.6ms 的时间里，浏览器既需要完成 JS 的执行，也需要完成样式的重排和重绘，如果 JS 执行的时间过长，超出了 16.6ms，这次刷新就没有时间执行样式布局和样式绘制了，于是在页面上就会表现为卡顿。
🔴 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 Reconcilation(中文可以译为协调.在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。
🔴所以React 是怎么优化的？ 划重点， 为了给用户制造一种应用很快的'假象'，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的'进程'，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。
🔴所以 React 通过Fiber 架构，让自己的Reconcilation（生成、对比 vdom） 过程变成可被中断（每次执行前，会切一小部分执行）。 '适时'地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:
 ·与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。
 ·给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正.

🔴Fiber 也称协程 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。要理解协程，你得和普通函数一起来看, 以Generator为例:
1、普通函数执行的过程中无法被中断和恢复：
2、React Fiber 的思想和协程的概念是契合的: 🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。(通过超时检查的机制来让出控制权。解决办法是: 确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器。)
使用 requestIdleCallback 让浏览器在'有空'的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕。
⼀种将recocilation（递归diff），拆分成⽆数个⼩任务的算法；它随时能够停⽌，恢复。停⽌恢复的时机取决于当前的⼀帧（16ms）内，还有没有⾜够的时间允许计算。（如果）

它的主要目标是支持虚拟DOM的增量渲染。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，
并为不同类型的更新分配优先级，以及新的并发原语。
React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中e

`Fiber总结`
🔴React Fiber是个什么东西呢？官方的一句话解释是 React Fiber是对核心算法的一次重新实现”。。
🔴当React决定要加载或者更新组件树时，会做很多事，比如调用各个组件的生命周期函数，计算和比对Virtual DOM，最后更新DOM树，这整个过程是同步进行的，也就是说只要一个加载或者更新过程开始，那React就以不破楼兰终不还的气概，一鼓作气运行到底，中途绝不停歇。（更新期间，用户操作任何东西得不到响应，只能等更新完毕）
🔴破解JavaScript中同步操作时间过长的方法其实很简单——分片。
把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。
React Fiber把更新过程碎片化，执行过程如下面的图所示，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。
维护每一个分片的数据结构，就是Fiber。
用户感知的性能才是真的性能


`vue 跟 react的dom更新`
react中数据发生变化（调用setstate时），render函数就会执行，重新生成一个新的虚拟dom，这个虚拟dom和旧的虚拟dom做比较，得出差异然后渲染。
而vue组件中数据发生变化，由于数据变化会触发setter，由于vue组件中数据的getter的作用，收集了依赖，setter触发会根据这些依赖，生成新的虚拟dom，然后对比新旧虚拟dom进行渲染。









`React 设计模式`

`首先 React 灵活多变性，就决定了 React 项目可以应用多种设计模式。但是这些设计模式的产生也确实办了实事:`

hoc 高阶组件

提供者模式 （connect 通过provide 把 state传下去）

类继承

...


`react中 useEffect 和 useLayoutEffect相同和区别`
不同点：useEffect 是在dom更新后异步执行 。useLayoutEffect 是在dom更新前同步执行（有可能会阻塞dom渲染），执行完再更新dom。useLayoutEffect可以解决更新dom时候屏幕闪烁的问题