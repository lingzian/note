<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
// 解耦了请求发送者和N个接受者之间的复杂关系。
// 多个对象均有机会触发，或者多个函数按照一定顺序触发（会有多个闭包，变量，函数与函数之间会耦合）， 处理多个处理函数之间的复杂关系，
// 当需求具有“传递”的性质时（代码中其中一种体现就是：多个if、else if、else if、else嵌套），就可以考虑将每个分支拆分成一个节点对象，拼接成为责任链。
// 缺点：当责任链过长，很多节点只有传递的作用，而不是真正地处理逻辑。
// 总结：我个人觉得，一般是多个函数都有几率参与，或者要按照某种特定顺序执行的情况下。能解耦，简化代码（if elseif elseif..  或者 多层闭包）
class Middleware {
  constructor() {
    this.$cache = []
    this.$middlewares = []
  }

  // 注册中间件
  use() {
    [...arguments].forEach(item => {
      if (typeof item === 'function') {
        this.$cache.push(item)
      }
    })
    return this
  }

  /**
   * 每个中间件只有两个形参 第一是传进来的参数 第二个是调用下一个中间件的函数
   * 中间件的执行顺序是根据你注册中间件的顺序来去调用的 
   */
  next(params) {
    if (this.$middlewares.length) {
      const ware = this.$middlewares.shift()
      ware.call(this, params, this.next.bind(this))
    }
  }
  
  execute(params) {
    this.$middlewares = this.$cache.map(fn => {  // 复制一份
      return fn;
    });
    this.next(params)
  }

}


const middleware = new Middleware()

function transform(options, next) {
  console.log('before', options.data);
  options.data.age = Number(options.data.age)
  console.log('this', this)
  next(options); // 通过验证
}

function validate(options, next) {
  console.log('validate', options.data);
  next(options); // 通过验证
}

function send(options, next) {
  setTimeout(function () { // 模拟异步
    console.log('send', options.data);
    next();
  }, 100);
}

middleware.use(transform).use(validate).use(send)
middleware.execute({ data: { name: 'cookie', age: '20' } });





// 发乎订阅
class Oberver {
  // 定义一个事件容器
  event = {}

  subscribe (type, fn) {
    // 消息类型不存在
    if (typeof this.event[type] === 'undefined') {
      this.event[type] = [fn]
    // 存在，将fn推入事件队列
    } else {
      this.event[type].push(fn)
    }
  }

  publish (type, args = {}) {
    // 消息类型没人订阅
    if (!this.event[type]) return
    let i = 0
    let len = this.event[type].length
    for (; i < len; i++) {
      // 依次执行事件队列（发布）
      this.event[type][i].call(this, {type, args})
    }
  }
}





function debunce (fn,time) {
  let timer = null
  return (...arg) => {
    let _this = this
    if(timer) clearTimeout(timer) 
    timer = setTimeout(() => {
      fn.apply(_this,arg)
    },time)
  }
}


function throll (fn, time) {
  let timer = null
  return (...arg) => {
    if(timer) return
    let _this = this
    timer = setTimeout(() => {
      timer = null
      fn.apply(_this,arg)
    },time)
  }
}


function deepClone(obj, map = new WeakMap()) {
  if(typeof obj !== 'object') return obj 
  if(obj instanceof Date) return new Date(obj)
  if(obj instanceof RegExp) return new RegExp(obg)
  if(map.has(obj)) {
    return map.get(obj)
  }
  let newObj = new obj.constructor()
  map.set(obj,newObj)
  for(key in obj) {
    newObj[key] = deepClone(obj[key])
  }
}


// call
Function.protorype.myCall = function(context,...args) {
  if(typeof this !== 'function') {
    throw new TypeError('类型错误')
  }
  context.fn = this
  const res = context.fn(...args)
  delete context.fn
  return res
}


// apply
Function.prototype.myApply = function(context, ...args) {
  if(typeof this !== 'function') {
    throw new TypeError('类型错误')
  }
  context.fn = this
  const res = context.fn(args)
  delete context.fn
  return res
}


// bind
Function.prototype.meBind = function(context,...args) {
  if(typeof this !== 'function') {
    throw new TypeError('类型错误')
  }
  let _this = this
  return function f() {
    if(this instanceof f) {
      return _this(...args,...arguments)
    }else {
      return _this.apply(context,[...args,...arguments])
    }
    
  }
}



  </script>
</body>
</html>