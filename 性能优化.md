DNS 解析耗时: domainLookupEnd - domainLookupStart
TCP 连接耗时: connectEnd - connectStart
SSL 安全连接耗时: connectEnd - secureConnectionStart
网络请求耗时 (TTFB): responseStart - requestStart
数据传输耗时: responseEnd - responseStart
DOM 解析耗时: domInteractive - responseEnd
资源加载耗时: loadEventStart - domContentLoadedEventEnd
First Byte时间: responseStart - domainLookupStart
白屏时间: responseEnd - fetchStart
首次可交互时间: domInteractive - fetchStart
DOM Ready 时间: domContentLoadEventEnd - fetchStart
页面完全加载时间: loadEventStart - fetchStart
http 头部大小： transferSize - encodedBodySize
重定向次数：performance.navigation.redirectCount
重定向耗时: redirectEnd - redirectStart


浏览器渲染过程
解析HTML生成DOM树。
解析CSS生成CSSOM规则树。
解析JS，操作 DOM 树和 CSSOM 规则树。
将DOM树与CSSOM规则树合并在一起生成渲染树。
遍历渲染树开始布局，计算每个节点的位置大小信息。
浏览器将所有图层的数据发送给GPU，GPU将图层合成并显示在屏幕上。


图片：
    1 优化图片质量
    2 雪碧图 (减少http请求)
    3 可以使用字体图标 svg等等
    4 避免图片src为空

js:
    1 把脚本放到页面底部
    2 使用事件委托
    3 减少dom操作
    4 减少重绘和回流
    5 列表加载可以使用虚拟节点
    6 使用 requestAnimationFrame 来实现视觉变化（大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。）

css: 
    把样式表放到head中
    利用css3代替图片效果
    少使用filter
    骨架屏

请求：
    延迟加载 （滚动加载）
    预加载 (在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验.例如使用img标签先加载一个隐藏图片，后面页面加载此图片会取缓存)
    缓存ajax请求
    使用http2(解析速度快，多路复用（只建立一个tcp连接）,首部压缩（每一个请求都会带有相同的信息，将其储存起来，仅发送不相同部分）)
    

服务端： 
    静态资源使用无cookie域名
    静态资源使用cdn（内容分发网络，自动取最近的服务器）
    服务端压缩


webpack: 
    1 tree-sharking 减少无用代码（但是这只能减少静态引入，动态引入需自己减少）
    2 通过analyzer分析什么资源比较多，然后再看时机情况按需加载，异步加载
    3 splitChunks 拆包（由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单 独提取出来）
    4 资源压缩，代码压缩
    5 在使用一些loader的时候，配置include和exclude，来确保转译尽可能少的文件。
    6 由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，可使用thread-loader 让Webpack 同一时刻处理多个任务
    7 js多进程压缩（本来webpack自带，缓存默认放到node_modules/.cache/terser-webpack-plugin）
    8 中间缓存 ，第一次构建没有变化，第二次开始可取缓存。hard-source-webpack-plugin





`spa 单页面白屏时间减少`
单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js 和vendor.js)，所以当网速差的时候会产生一定程度的白屏
1、路由懒加载，组件懒加载 （splitChunks 拆包）
2、CDN 资源优化
3、打包的时候资源压缩，服务器也压缩一次
4、图片质量大小，iocnfont