`模块化`
在日益复杂和多元的Web业务背景下，前端工程化这个概念经常被提及。“说说你对Web工程化的理解？” 相信很多初学者在面试时会经常遇到，而大多数人脑子会直接浮现出 Webpack，认为工程化就是 Webpack 做的那些事情儿，当然也不能说不对，准确说 Webpack 只是工程化背景下产生的工具。


工程化的目的是高性能、是稳定性、是可用性、是可维护性、是高效协同，只要是以这几个角度为目标所做的操作，都可称为工程化的一部分。工程化其实是软件工程中的一种思想。当下的前端工程化可以分为四个方面：模块化、组件化、规范化、自动化 。


`为什么需要模块化`
模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。
各种交互以及新技术等使网页变得越来越丰富，逐渐我们前端工程师登上了舞台，同时也使得我们前端同学的代码量急速上涨、复杂度在逐步增高，越来越多的业务逻辑和交互都放在 Web 层实现，代码一多，各种命名冲突、代码冗余、文件间依赖变大等等一系列的问题就出来了，甚至导致后期难以维护。


`早期模块化`
普通函数

立即执行函数（IIFE）

CommonJS 特点: require、module.exports、exports CommonJS 一般用在服务端或者Node用来同步加载模块，模块输出的是值的拷贝，一旦输出之后，无论模块内部怎么变化，都无法影响之前的引用。

ESModule import、export ES6模块化不是对象，import会在JavaScript引擎静态分析，在编译时就引入模块代码，而并非在代码运行时加载，因此也不适合异步加载。
但是 后来引入了import()函数类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。